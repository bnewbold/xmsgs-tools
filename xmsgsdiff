#!/usr/bin/env python
"""
..
    Copyright: LeafLabs, LLC, 2014
    License: MIT License
    Author: bnewbold@leaflabs.com
    Date: Feb 2014


"""

from __future__ import print_function
import argparse
import logging as log
import pprint
import xml.etree.ElementTree as ET
import re
import os
import sys
import glob

pp = pprint.PrettyPrinter()

DISABLE_COLOR = False

SEVERE_WARNINGS = [
    413,    # "N-bit expression truncated into M-bit target"
    ]

IGNORE_LIST = []
USE_TYPES = ['error', 'warning', 'severe', 'info']
SKIP_PATHS = []


def colorize(what, how, bold=False):
    """
    See also: https://pypi.python.org/pypi/colorama
    """
    if DISABLE_COLOR:
        return what

    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    BGRED = '\033[41m'
    BGGREEN = '\033[42m'
    BGYELLOW = '\033[43m'
    BGBLUE = '\033[44m'
    BGWHITE = '\033[47m'
    DIM = '\033[2m'
    ENDC = '\033[0m'

    if bold:
        BOLD = '\033[1m'
    else:
        BOLD = ''

    if how in ['red', 'error', 'fail']:
        return RED + BOLD + what + ENDC
    elif how in ['green', 'ok', 'success']:
        return GREEN + BOLD + what + ENDC
    elif how in ['magenta', 'severe']:
        return MAGENTA + BOLD + what + ENDC
    elif how in ['yellow', 'warning']:
        return YELLOW + BOLD + what + ENDC
    elif how in ['grey', 'gray', 'info']:
        return CYAN + BOLD + what + ENDC
    elif how in ['bgred']:
        return BGRED + BLACK + BOLD + what + ENDC
    elif how in ['bggreen']:
        return BGGREEN + BLACK + BOLD + what + ENDC
    elif how in ['bgwhite']:
        return BGWHITE + BLACK + BOLD + what + ENDC
    elif how in ['bgblue']:
        return BGBLUE + BLACK + BOLD + what + ENDC
    else:
        return BOLD + what + ENDC


def strlim(s, l):
    if len(s) > l:
        return s[:l-3] + "..."
    else:
        return s


def msg2dict(msg):
    raw = msg.text
    for child in msg:
        raw += child.text
        raw += child.tail
    raw = raw.strip()
    fullpath = None
    path = None
    linenum = None
    text = raw
    r = re.compile('\"(\S+)\" [Ll]ine (\d+): (.+)')
    m = r.match(raw)
    if m is not None:
        fullpath = m.group(1)
        path = os.path.relpath(fullpath)
        linenum = int(m.group(2))
        text = m.group(3)
        for pattern in SKIP_PATHS:
            if glob.fnmatch.fnmatch(path, pattern):
                return None
    num = int(msg.attrib['num'])
    type = msg.attrib['type']
    if num in SEVERE_WARNINGS:
        type = 'severe'
    if num in IGNORE_LIST or not type in USE_TYPES:
        return None
    return {'type': type,
            'source': msg.attrib['file'],
            'num': num,
            'delta': msg.attrib['delta'],
            'fulltext': raw,
            'text': text,
            'fullpath': fullpath,
            'path': path,
            'count': 1,
            'linenum': linenum}


def parse(before_files, after_files):
    tmpl = {'add': 0,
            'remove': 0,
            'before': 0,
            'after': 0}
    counts = {'duplicate': 0,
              'error': tmpl.copy(),
              'warning': tmpl.copy(),
              'severe': tmpl.copy(),
              'info': tmpl.copy()}
    before_dict = {}
    for before in before_files:
        before_tree = ET.parse(before)
        for msg in before_tree.iter('msg'):
            m = msg2dict(msg)
            if not m:
                continue
            t = m['type']
            if m['fulltext'] in before_dict:
                counts['duplicate'] = counts['duplicate'] + 1
                m['count'] = m['count'] + 1
            before_dict[m['fulltext']] = m
            counts[t]['before'] = counts[t]['before'] + 1

    add_list = []
    after_dict = {}
    for after in after_files:
        after_tree = ET.parse(after)
        for msg in after_tree.iter('msg'):
            m = msg2dict(msg)
            if not m:
                continue
            t = m['type']
            if m['fulltext'] in after_dict:
                counts['duplicate'] = counts['duplicate'] + 1
                m['count'] = m['count'] + 1
            after_dict[m['fulltext']] = m
            if m['fulltext'] in before_dict.keys():
                before_dict.pop(m['fulltext'])
            else:
                add_list.append(m)
                counts[t]['add'] = counts[t]['add'] + 1
            counts[t]['after'] = counts[t]['after'] + 1

    for m in before_dict.values():
        t = m['type']
        counts[t]['remove'] = counts[t]['remove'] + 1
    return (add_list, before_dict.values(), counts)



def print_msgs(msgs, difftype=None, full=False):
    if difftype is 'add':
        lineprefix = colorize("+", 'bggreen')
    elif difftype is 'remove':
        lineprefix = colorize("-", 'bgred')
    else:
        lineprefix = "?"

    for m in msgs:
        prefix = m['source'] + ":" + str(m['num']) + ": "
        if full:
            body = m['text']
        else:
            body = strlim(m['text'], 77 - len(prefix))
        print(lineprefix +
              colorize(prefix, m['type'], bold=True) +
              colorize(body, m['type']))


def print_by_file(add, remove, full=False):
    fdict = {'<unknown>': {'add': [], 'remove': []}}
    for m in add:
        if not m['path']:
            fdict['<unknown>']['add'].append(m)
            continue
        if not fdict.has_key(m['path']): 
            fdict[m['path']] = {'add': [], 'remove': []}
        fdict[m['path']]['add'].append(m)
    for m in remove:
        if not m['path']:
            fdict['<unknown>']['add'].append(m)
            continue
        if not fdict.has_key(m['path']): 
            fdict[m['path']] = {'add': [], 'remove': []}
        fdict[m['path']]['remove'].append(m)
    for key in sorted(fdict.keys()):
        print(colorize("--- " + key, 'bgwhite'))
        print_msgs(fdict[key]['add'], 'add', full=full)
        print_msgs(fdict[key]['remove'], 'remove', full=full)


def print_counts(counts):
    print(("=== Summary " + "=" * 79)[:79])
    def helper(name, c):
        print("%020s %s (%s, %s)" % (
            name + ':',
            colorize(str(c['after']), '', bold=True),
            colorize("+" + str(c['add']), 'green', bold=True), 
            colorize("-" + str(c['remove']), 'red', bold=True)))

    if 'error' in USE_TYPES:
        helper('Errors', counts['error'])
    if 'severe' in USE_TYPES:
        helper('Severe Warnings', counts['severe'])
    if 'warning' in USE_TYPES:
        helper('Warnings', counts['warning'])
    if 'info' in USE_TYPES:
        helper('Infos', counts['info'])


# ========== Script/Args =========== #
def main():
    global DISABLE_COLOR
    global IGNORE_LIST
    global USE_TYPES

    parser = argparse.ArgumentParser(
        description="Shows the diff! Of the things!",
        usage="%(prog)s [options]")
    parser.add_argument('-v', '--verbose', action="count",
        help="more verbose (debugging) output")
    parser.add_argument('-f', '--full', action="store_true",
        help="display full output")
    parser.add_argument('-b', '--by-file', action="store_true",
        help="Display outputs by filename")
    parser.add_argument('-s', '--skip-paths', nargs="+",
        help="Skip paths (can be globs)")
    parser.add_argument('--show-path', action="store_true",
        help="show file paths (when possible); implies --full")
    parser.add_argument('before_file', type=str,
        help="")
    parser.add_argument('after_file', type=str,
        help="")
    parser.add_argument('-i', '--ignore', nargs="+", type=int,
        help="list of warnings to ignore (integers)")
    parser.add_argument('-t', '--types', nargs="+", type=str,
        help="list of types to handle (error, warning, info, severe)")

    args = parser.parse_args()

    if args.verbose > 0:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.DEBUG)
    else:
        log.basicConfig(format="%(levelname)s: %(message)s")

    if not os.isatty(sys.stdout.fileno()):
        DISABLE_COLOR = True

    if args.ignore:
        IGNORE_LIST.extend(args.ignore)

    if args.types:
        USE_TYPES = args.types

    if args.skip_paths:
        SKIP_PATHS.extend(args.skip_paths)

    if os.path.isdir(args.before_file):
        before_files = glob.glob(args.before_file + "/*xmsgs")
    else:
        before_files = [args.before_file, ]

    if os.path.isdir(args.after_file):
        after_files = glob.glob(args.after_file + "/*xmsgs")
    else:
        after_files = [args.after_file, ]

    (add, remove, counts) = parse(before_files, after_files)
    if args.by_file:
        print_by_file(add, remove, full=args.full)
    else:
        print_msgs(remove, 'remove', full=args.full)
        print_msgs(add, 'add', full=args.full)
    print_counts(counts)

if __name__ == '__main__':
    main()

